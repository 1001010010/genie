/*
 * Copyright 2014 Netflix, Inc.
 *
 *      Licensed under the Apache License, Version 2.0 (the "License");
 *      you may not use this file except in compliance with the License.
 *      You may obtain a copy of the License at
 *
 *          http://www.apache.org/licenses/LICENSE-2.0
 *
 *      Unless required by applicable law or agreed to in writing, software
 *      distributed under the License is distributed on an "AS IS" BASIS,
 *      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *      See the License for the specific language governing permissions and
 *      limitations under the License.
 */
package com.netflix.genie.server.repository.jpa;

import com.netflix.genie.common.model.Job;
import com.netflix.genie.common.model.JobStatus;
import com.netflix.genie.common.model.Job_;
import junit.framework.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import org.springframework.data.jpa.domain.Specification;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Path;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import java.util.Date;
import java.util.UUID;

/**
 * Test the specifications generated by JobSpecs.
 *
 * @author tgianos
 */
public class TestJobSpecs {

    private static final String ID = UUID.randomUUID().toString();
    private static final String JOB_NAME = "jobName";
    private static final String USER_NAME = "tgianos";
    private static final String CLUSTER_NAME = "hprod2";
    private static final String CLUSTER_ID = "prod";

    private Root<Job> root;
    private CriteriaQuery<?> cq;
    private CriteriaBuilder cb;

    /**
     * Setup the mocks.
     */
    @Before
    @SuppressWarnings("unchecked")
    public void setup() {
        this.root = (Root<Job>) Mockito.mock(Root.class);
        this.cq = Mockito.mock(CriteriaQuery.class);
        this.cb = Mockito.mock(CriteriaBuilder.class);

        final Path<String> idPath = (Path<String>) Mockito.mock(Path.class);
        final Predicate likeIdPredicate = Mockito.mock(Predicate.class);
        Mockito.when(this.root.get(Job_.id)).thenReturn(idPath);
        Mockito.when(this.cb.like(idPath, ID)).thenReturn(likeIdPredicate);

        final Path<String> jobNamePath = (Path<String>) Mockito.mock(Path.class);
        final Predicate likeJobNamePredicate = Mockito.mock(Predicate.class);
        Mockito.when(this.root.get(Job_.name)).thenReturn(jobNamePath);
        Mockito.when(this.cb.like(jobNamePath, JOB_NAME))
                .thenReturn(likeJobNamePredicate);

        final Path<String> userNamePath = (Path<String>) Mockito.mock(Path.class);
        final Predicate equalUserNamePredicate = Mockito.mock(Predicate.class);
        Mockito.when(this.root.get(Job_.user)).thenReturn(userNamePath);
        Mockito.when(this.cb.equal(userNamePath, USER_NAME))
                .thenReturn(equalUserNamePredicate);

        final Path<JobStatus> statusPath = (Path<JobStatus>) Mockito.mock(Path.class);
        final Predicate equalStatusPredicate = Mockito.mock(Predicate.class);
        Mockito.when(this.root.get(Job_.status)).thenReturn(statusPath);
        Mockito.when(this.cb.equal(statusPath, JobStatus.INIT))
                .thenReturn(equalStatusPredicate);

        final Path<String> clusterNamePath = (Path<String>) Mockito.mock(Path.class);
        final Predicate equalClusterNamePredicate = Mockito.mock(Predicate.class);
        Mockito.when(this.root.get(Job_.executionClusterName))
                .thenReturn(clusterNamePath);
        Mockito.when(this.cb.equal(clusterNamePath, CLUSTER_NAME))
                .thenReturn(equalClusterNamePredicate);

        final Path<String> clusterIdPath = (Path<String>) Mockito.mock(Path.class);
        final Predicate equalClusterIdPredicate = Mockito.mock(Predicate.class);
        Mockito.when(this.root.get(Job_.executionClusterId))
                .thenReturn(clusterIdPath);
        Mockito.when(this.cb.equal(clusterIdPath, CLUSTER_ID))
                .thenReturn(equalClusterIdPredicate);
    }

    /**
     * Test the find specification.
     */
    @Test
    public void testFindWithAll() {
        final Specification<Job> spec = JobSpecs.find(
                ID,
                JOB_NAME,
                USER_NAME,
                JobStatus.INIT,
                CLUSTER_NAME,
                CLUSTER_ID
        );

        spec.toPredicate(this.root, this.cq, this.cb);
        Mockito.verify(this.cb, Mockito.times(1))
                .like(this.root.get(Job_.id), ID);
        Mockito.verify(this.cb, Mockito.times(1))
                .like(this.root.get(Job_.name), JOB_NAME);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.user), USER_NAME);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.status), JobStatus.INIT);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.executionClusterName), CLUSTER_NAME);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.executionClusterId), CLUSTER_ID);
    }

    /**
     * Test the find specification.
     */
    @Test
    public void testFindWithOutId() {
        final Specification<Job> spec = JobSpecs.find(
                null,
                JOB_NAME,
                USER_NAME,
                JobStatus.INIT,
                CLUSTER_NAME,
                CLUSTER_ID
        );

        spec.toPredicate(this.root, this.cq, this.cb);
        Mockito.verify(this.cb, Mockito.never())
                .like(this.root.get(Job_.id), ID);
        Mockito.verify(this.cb, Mockito.times(1))
                .like(this.root.get(Job_.name), JOB_NAME);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.user), USER_NAME);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.status), JobStatus.INIT);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.executionClusterName), CLUSTER_NAME);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.executionClusterId), CLUSTER_ID);
    }

    /**
     * Test the find specification.
     */
    @Test
    public void testFindWithOutJobName() {
        final Specification<Job> spec = JobSpecs.find(
                ID,
                "",
                USER_NAME,
                JobStatus.INIT,
                CLUSTER_NAME,
                CLUSTER_ID
        );

        spec.toPredicate(this.root, this.cq, this.cb);
        Mockito.verify(this.cb, Mockito.times(1))
                .like(this.root.get(Job_.id), ID);
        Mockito.verify(this.cb, Mockito.never())
                .like(this.root.get(Job_.name), JOB_NAME);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.user), USER_NAME);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.status), JobStatus.INIT);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.executionClusterName), CLUSTER_NAME);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.executionClusterId), CLUSTER_ID);
    }

    /**
     * Test the find specification.
     */
    @Test
    public void testFindWithOutUserName() {
        final Specification<Job> spec = JobSpecs.find(
                ID,
                JOB_NAME,
                " ",
                JobStatus.INIT,
                CLUSTER_NAME,
                CLUSTER_ID
        );

        spec.toPredicate(this.root, this.cq, this.cb);
        Mockito.verify(this.cb, Mockito.times(1))
                .like(this.root.get(Job_.id), ID);
        Mockito.verify(this.cb, Mockito.times(1))
                .like(this.root.get(Job_.name), JOB_NAME);
        Mockito.verify(this.cb, Mockito.never())
                .equal(this.root.get(Job_.user), USER_NAME);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.status), JobStatus.INIT);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.executionClusterName), CLUSTER_NAME);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.executionClusterId), CLUSTER_ID);
    }

    /**
     * Test the find specification.
     */
    @Test
    public void testFindWithOutStatus() {
        final Specification<Job> spec = JobSpecs.find(
                ID,
                JOB_NAME,
                USER_NAME,
                null,
                CLUSTER_NAME,
                CLUSTER_ID
        );

        spec.toPredicate(this.root, this.cq, this.cb);
        Mockito.verify(this.cb, Mockito.times(1))
                .like(this.root.get(Job_.id), ID);
        Mockito.verify(this.cb, Mockito.times(1))
                .like(this.root.get(Job_.name), JOB_NAME);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.user), USER_NAME);
        Mockito.verify(this.cb, Mockito.never())
                .equal(this.root.get(Job_.status), JobStatus.INIT);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.executionClusterName), CLUSTER_NAME);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.executionClusterId), CLUSTER_ID);
    }

    /**
     * Test the find specification.
     */
    @Test
    public void testFindWithOutClusterName() {
        final Specification<Job> spec = JobSpecs.find(
                ID,
                JOB_NAME,
                USER_NAME,
                JobStatus.INIT,
                null,
                CLUSTER_ID
        );

        spec.toPredicate(this.root, this.cq, this.cb);
        Mockito.verify(this.cb, Mockito.times(1))
                .like(this.root.get(Job_.id), ID);
        Mockito.verify(this.cb, Mockito.times(1))
                .like(this.root.get(Job_.name), JOB_NAME);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.user), USER_NAME);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.status), JobStatus.INIT);
        Mockito.verify(this.cb, Mockito.never())
                .equal(this.root.get(Job_.executionClusterName), CLUSTER_NAME);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.executionClusterId), CLUSTER_ID);
    }

    /**
     * Test the find specification.
     */
    @Test
    public void testFindWithOutClusterId() {
        final Specification<Job> spec = JobSpecs.find(
                ID,
                JOB_NAME,
                USER_NAME,
                JobStatus.INIT,
                CLUSTER_NAME,
                null
        );

        spec.toPredicate(this.root, this.cq, this.cb);
        Mockito.verify(this.cb, Mockito.times(1))
                .like(this.root.get(Job_.id), ID);
        Mockito.verify(this.cb, Mockito.times(1))
                .like(this.root.get(Job_.name), JOB_NAME);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.user), USER_NAME);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.status), JobStatus.INIT);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.executionClusterName), CLUSTER_NAME);
        Mockito.verify(this.cb, Mockito.never())
                .equal(this.root.get(Job_.executionClusterId), CLUSTER_ID);
    }

    /**
     * Test the find zombie specification.
     */
    @Test
    @SuppressWarnings("unchecked")
    public void testFindZombies() {
        final long diff = 54000L;
        final Date now = new Date();
        final Date before = new Date(now.getTime() - diff);

        final Path<Date> updatedPath = (Path<Date>) Mockito.mock(Path.class);
        final Predicate lessThanUpdatedPredicate = Mockito.mock(Predicate.class);
        Mockito.when(this.root.get(Job_.updated)).thenReturn(updatedPath);
        Mockito.when(this.cb.lessThan(updatedPath, new Date(diff)))
                .thenReturn(lessThanUpdatedPredicate);

        final Path<JobStatus> runningPath = (Path<JobStatus>) Mockito.mock(Path.class);
        final Predicate equalRunningPredicate = Mockito.mock(Predicate.class);
        Mockito.when(this.root.get(Job_.status)).thenReturn(runningPath);
        Mockito.when(this.cb.equal(runningPath, JobStatus.RUNNING))
                .thenReturn(equalRunningPredicate);

        final Path<JobStatus> initPath = (Path<JobStatus>) Mockito.mock(Path.class);
        final Predicate equalInitPredicate = Mockito.mock(Predicate.class);
        Mockito.when(this.root.get(Job_.status)).thenReturn(initPath);
        Mockito.when(this.cb.equal(initPath, JobStatus.INIT))
                .thenReturn(equalInitPredicate);

        final Predicate orPredicate = Mockito.mock(Predicate.class);
        Mockito.when(this.cb.or(equalRunningPredicate, equalInitPredicate))
                .thenReturn(orPredicate);

        final Specification<Job> findZombies = JobSpecs.findZombies(
                now.getTime(),
                before.getTime()
        );
        findZombies.toPredicate(this.root, this.cq, this.cb);
        Mockito.verify(this.cb, Mockito.times(1))
                .lessThan(this.root.get(Job_.updated), new Date(diff));
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.status), JobStatus.RUNNING);
        Mockito.verify(this.cb, Mockito.times(1))
                .equal(this.root.get(Job_.status), JobStatus.INIT);
        Mockito.verify(this.cb, Mockito.times(1))
                .or(Mockito.any(Predicate.class), Mockito.any(Predicate.class));
    }

    /**
     * Just for completing coverage.
     */
    @Test
    public void testProtectedConstructor() {
        final JobSpecs specs = new JobSpecs();
        Assert.assertEquals(JobSpecs.class, specs.getClass());
    }
}
